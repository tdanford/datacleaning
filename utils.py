import string
import re
import sys
from pprint import pprint

"""
utils.py is a library of methods for dealing with streams (or lists) of tuples
and objects as generated by some of the other libraries for data cleaning, here.
"""

def query( stream ): 
	"""
	Takes a generator and returns a list. The terminal operator in a lot of operations.

	>>> query([1, 2, 3]) 
	[1, 2, 3]
	"""

	return [x for x in stream]

def table( tuple_stream, outf=sys.stdout ): 
	"""
	Pretty-prints out a table of tuples, where each column is adjusted (via padding with 
	spaces) to the right width.
	"""
	def find_length( tvalues, i ): 
		lens = [len(str(t[i])) for t in tvalues]
		return max(lens)

	table_values = query(tuple_stream)
	if len(table_values) > 0: 
		indices = range(len(table_values[0]))
		lengths = [ find_length(table_values, i) for i in indices ]
		for tup in table_values:
			for i in indices: 
				if i > 0: outf.write('\t')
				outf.write(str(tup[i]).ljust(lengths[i], ' '))
			outf.write('\n')

def tuples( keys, object_stream ): 
	"""
	Extracts a stream of objects into a stream of tuples.  
	The first argument, 'keys', is a list-of-strings which are the keys 
	of the objects (and the order of those keys) in which to extract the values; 
	if 'keys' is not specified (i.e. is None or false-y), then the keys of the 
	first object are used instead.

	>>> query(tuples(['foo', 'bar'], [{ 'foo': 1, 'bar': 2 }, { 'foo': 3, 'bar': 4 }] ))
	[(1, 2), (3, 4)]

	'tuples' is the dual of 'objects'
	>>> query(tuples(['foo', 'bar'], objects(['foo', 'bar'], [(1, 2), (3, 4)] )))
	[(1, 2), (3, 4)]
	"""
	kk = keys
	for obj in object_stream: 
		if not kk: kk = obj.keys()
		yield tuple( obj[k] for k in kk )

def objects( keys, tuple_stream ): 
	"""
	Extracts a stream of tuples into a stream of objects.
	The 'keys' argument, which is required, is used for naming each member of a tuple
	as it is inserted into the corresponding object.

	>>> query(objects(['foo', 'bar'], [(1, 2), (3, 4)]))
	[{'foo': 1, 'bar': 2}, {'foo': 3, 'bar': 4}]

	'objects' is the dual of 'tuples'
	>>> query(objects(['foo', 'bar'], tuples(['foo', 'bar'], [{'foo': 1, 'bar': 2}, {'foo': 3, 'bar': 4}])))
	[{'foo': 1, 'bar': 2}, {'foo': 3, 'bar': 4}]
	"""
	for tup in tuple_stream: 
		yield { keys[i]: tup[i] for i in range(len(keys)) }

def tuple_project( indices, tuple_stream ): 
	"""
	Projects a stream of tuples down to a subset of the indices
	>>> query(tuple_project([1, 3], [(0, 1, 2, 3), (10, 11, 12, 13)]))
	[(1, 3), (11, 13)]
	"""
	for tup in tuple_stream: 
		yield tuple( tup[i] for i in indices )

def object_project( keys, object_stream ): 
	"""
	Projects a stream of objects down onto a subset of the keys
	>>> query(object_project(['foo', 'bar'], [{'foo': 1, 'bar': 2, 'grok': 3}, {'foo': 10, 'bar': 11, 'grok': 12 }]))
	[{'foo': 1, 'bar': 2}, {'foo': 10, 'bar': 11}]
	"""
	for obj in object_stream: 
		yield { k: obj[k] for k in keys }

def object_subtract( keys, object_stream ): 
	"""
	The dual of project -- removes the keys specified from the objects.
	>>> query(object_subtract(['foo'], [{'foo': 1, 'bar': 1}, {'foo': 2, 'bar': 2}]))
	[{'bar': 1}, {'bar': 2}]
	"""
	for obj in object_stream: 
		yield { k: obj[k] for k in obj.keys() if not k in keys }

def filter( pred, stream ): 
	"""
	>>> query(filter(lambda x: x > 3, [1, 2, 3, 4, 5]))
	[4, 5]
	"""
	for value in stream: 
		if pred(value):
			yield value

def group_tuples_by( index, stream ): 
	"""
	Groups a set of tuples by the values in the specified index
	>>> query(group_tuples_by(0, [(1, 1), (1, 2), (2, 1)]))
	[(1, [(1, 1), (1, 2)]), (2, [(2, 1)])]
	"""
	keyed = {}
	for tup in stream: 
		if not tup[index] in keyed: keyed[tup[index]] = []
		keyed[tup[index]].append(tup)
	return [ (k, keyed[k]) for k in keyed.keys() ]

def group_objects_by( key, stream ): 
	"""
	Groups a set of objects by the values in the specified key
	>>> query(group_objects_by('foo', [{'foo': 1, 'bar': 1}, {'foo': 1, 'bar': 2}, {'foo': 2, 'bar': 1}]))
	[(1, [{'foo': 1, 'bar': 1}, {'foo': 1, 'bar': 2}]), (2, [{'foo': 2, 'bar': 1}])]
	"""
	keyed = {}
	for obj in stream: 
		if not obj[key] in keyed: keyed[obj[key]] = []
		keyed[obj[key]].append(obj)
	return [ (k, keyed[k]) for k in keyed.keys()]

def flatten_matrix( keys, tuple_stream ): 
	for tup in tuple_stream: 
		for i in range(1, len(keys)):
			yield ( tup[0], keys[i], tup[i] ) 

def lookup( dict_value ): 
	"""
	Given a dictionary-like value, returns a function which looks up values within 
	that dictionary.

	>>> lookup({'foo': 3})('foo')
	3

	>>> print lookup({'foo': 3})('bar')
	None
	"""
	def looker( value ): 
		if value in dict_value: return dict_value[value]
		else: return None
	return looker

def flatmap( f, stream ): 
	"""
	>>> query(flatmap(lookup({'foo': 1, 'bar': 2}), ['foo', 'bar']))
	[1, 2]

	>>> query(flatmap(lookup({'foo': [1, 2], 'bar': [3]}), ['foo', 'bar', 'grok']))
	[1, 2, 3]
	"""
	def flatvals(v): 
		if not v: return []
		elif hasattr(v, '__iter__'): return v
		else: return [v]
	for val in stream: 
		for innerv in flatvals(f(val)):
			yield innerv

def count( stream ): 
	"""
	Takes a stream of (key, sequence-of-values) tuples, and produces
	a stream of (key, integer-count) values

	>>> query(count([('foo', [1, 2]), ('bar', [3])]))
	[('foo', 2), ('bar', 1)]
	"""
	for (k, values) in stream: 
		yield (k, len(values))
